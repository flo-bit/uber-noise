var v0=Object.create;var{defineProperty:f0,getPrototypeOf:d0,getOwnPropertyNames:z0}=Object;var w0=Object.prototype.hasOwnProperty;var l0=(C,E,L)=>{L=C!=null?v0(d0(C)):{};const D=E||!C||!C.__esModule?f0(L,"default",{value:C,enumerable:!0}):L;for(let I of z0(C))if(!w0.call(D,I))f0(D,I,{get:()=>C[I],enumerable:!0});return D};var t0=(C,E)=>()=>(E||C((E={exports:{}}).exports,E),E.exports);var j0=t0((F0,g0)=>{(function(C,E){if(typeof F0==="object")g0.exports=E();else if(typeof define==="function"&&define.amd)define(E);else C.Alea=E()})(F0,function(){return C.importState=function(L){var D=new C;return D.importState(L),D},C;function C(){return function(L){var D=0,I=0,_=0,B=1;if(L.length==0)L=[+new Date];var H=E();D=H(" "),I=H(" "),_=H(" ");for(var S=0;S<L.length;S++){if(D-=H(L[S]),D<0)D+=1;if(I-=H(L[S]),I<0)I+=1;if(_-=H(L[S]),_<0)_+=1}H=null;var K=function(){var T=2091639*D+B*0.00000000023283064365386964;return D=I,I=_,_=T-(B=T|0)};return K.next=K,K.uint32=function(){return K()*4294967296},K.fract53=function(){return K()+(K()*2097152|0)*0.00000000000000011102230246251566},K.version="Alea 0.9",K.args=L,K.exportState=function(){return[D,I,_,B]},K.importState=function(T){D=+T[0]||0,I=+T[1]||0,_=+T[2]||0,B=+T[3]||0},K}(Array.prototype.slice.call(arguments))}function E(){var L=4022871197,D=function(I){I=I.toString();for(var _=0;_<I.length;_++){L+=I.charCodeAt(_);var B=0.02519603282416938*L;L=B>>>0,B-=L,B*=L,L=B>>>0,B-=L,L+=B*4294967296}return(L>>>0)*0.00000000023283064365386964};return D.version="Mash 0.9",D}})});function c0(C=Math.random){const E=A0(C),L=new Float64Array(E).map((I)=>h0[I%12*2]),D=new Float64Array(E).map((I)=>h0[I%12*2+1]);return function I(_,B){let H=0,S=0,K=0;const T=(_+B)*y0,W=v(_+T),b=v(B+T),U=(W+b)*B0,c=W-U,G=b-U,Y=_-c,F=B-G;let N,u;if(Y>F)N=1,u=0;else N=0,u=1;const k=Y-N+B0,Q=F-u+B0,A=Y-1+2*B0,q=F-1+2*B0,f=W&255,h=b&255;let V=0.5-Y*Y-F*F;if(V>=0){const J=f+E[h],X=L[J],Z=D[J];V*=V,H=V*V*(X*Y+Z*F)}let $=0.5-k*k-Q*Q;if($>=0){const J=f+N+E[h+u],X=L[J],Z=D[J];$*=$,S=$*$*(X*k+Z*Q)}let M=0.5-A*A-q*q;if(M>=0){const J=f+1+E[h+1],X=L[J],Z=D[J];M*=M,K=M*M*(X*A+Z*q)}return 70*(H+S+K)}}function N0(C=Math.random){const E=A0(C),L=new Float64Array(E).map((_)=>Y0[_%12*3]),D=new Float64Array(E).map((_)=>Y0[_%12*3+1]),I=new Float64Array(E).map((_)=>Y0[_%12*3+2]);return function _(B,H,S){let K,T,W,b;const U=(B+H+S)*0.3333333333333333,c=v(B+U),G=v(H+U),Y=v(S+U),F=(c+G+Y)*0.16666666666666666,N=c-F,u=G-F,k=Y-F,Q=B-N,A=H-u,q=S-k;let f,h,V,$,M,J;if(Q>=A)if(A>=q)f=1,h=0,V=0,$=1,M=1,J=0;else if(Q>=q)f=1,h=0,V=0,$=1,M=0,J=1;else f=0,h=0,V=1,$=1,M=0,J=1;else if(A<q)f=0,h=0,V=1,$=0,M=1,J=1;else if(Q<q)f=0,h=1,V=0,$=0,M=1,J=1;else f=0,h=1,V=0,$=1,M=1,J=0;const X=Q-f+0.16666666666666666,Z=A-h+0.16666666666666666,g=q-V+0.16666666666666666,j=Q-$+0.3333333333333333,s=A-M+0.3333333333333333,p=q-J+0.3333333333333333,n=Q-1+0.5,e=A-1+0.5,i=q-1+0.5,y=c&255,x=G&255,m=Y&255;let d=0.6-Q*Q-A*A-q*q;if(d<0)K=0;else{const O=y+E[x+E[m]];d*=d,K=d*d*(L[O]*Q+D[O]*A+I[O]*q)}let z=0.6-X*X-Z*Z-g*g;if(z<0)T=0;else{const O=y+f+E[x+h+E[m+V]];z*=z,T=z*z*(L[O]*X+D[O]*Z+I[O]*g)}let w=0.6-j*j-s*s-p*p;if(w<0)W=0;else{const O=y+$+E[x+M+E[m+J]];w*=w,W=w*w*(L[O]*j+D[O]*s+I[O]*p)}let l=0.6-n*n-e*e-i*i;if(l<0)b=0;else{const O=y+1+E[x+1+E[m+1]];l*=l,b=l*l*(L[O]*n+D[O]*e+I[O]*i)}return 32*(K+T+W+b)}}function u0(C=Math.random){const E=A0(C),L=new Float64Array(E).map((B)=>H0[B%32*4]),D=new Float64Array(E).map((B)=>H0[B%32*4+1]),I=new Float64Array(E).map((B)=>H0[B%32*4+2]),_=new Float64Array(E).map((B)=>H0[B%32*4+3]);return function B(H,S,K,T){let W,b,U,c,G;const Y=(H+S+K+T)*x0,F=v(H+Y),N=v(S+Y),u=v(K+Y),k=v(T+Y),Q=(F+N+u+k)*R,A=F-Q,q=N-Q,f=u-Q,h=k-Q,V=H-A,$=S-q,M=K-f,J=T-h;let X=0,Z=0,g=0,j=0;if(V>$)X++;else Z++;if(V>M)X++;else g++;if(V>J)X++;else j++;if($>M)Z++;else g++;if($>J)Z++;else j++;if(M>J)g++;else j++;const s=X>=3?1:0,p=Z>=3?1:0,n=g>=3?1:0,e=j>=3?1:0,i=X>=2?1:0,y=Z>=2?1:0,x=g>=2?1:0,m=j>=2?1:0,d=X>=1?1:0,z=Z>=1?1:0,w=g>=1?1:0,l=j>=1?1:0,O=V-s+R,J0=$-p+R,K0=M-n+R,V0=J-e+R,$0=V-i+2*R,M0=$-y+2*R,P0=M-x+2*R,T0=J-m+2*R,O0=V-d+3*R,S0=$-z+3*R,Q0=M-w+3*R,R0=J-l+3*R,W0=V-1+4*R,q0=$-1+4*R,X0=M-1+4*R,Z0=J-1+4*R,o=F&255,a=N&255,r=u&255,C0=k&255;let E0=0.6-V*V-$*$-M*M-J*J;if(E0<0)W=0;else{const P=o+E[a+E[r+E[C0]]];E0*=E0,W=E0*E0*(L[P]*V+D[P]*$+I[P]*M+_[P]*J)}let L0=0.6-O*O-J0*J0-K0*K0-V0*V0;if(L0<0)b=0;else{const P=o+s+E[a+p+E[r+n+E[C0+e]]];L0*=L0,b=L0*L0*(L[P]*O+D[P]*J0+I[P]*K0+_[P]*V0)}let D0=0.6-$0*$0-M0*M0-P0*P0-T0*T0;if(D0<0)U=0;else{const P=o+i+E[a+y+E[r+x+E[C0+m]]];D0*=D0,U=D0*D0*(L[P]*$0+D[P]*M0+I[P]*P0+_[P]*T0)}let I0=0.6-O0*O0-S0*S0-Q0*Q0-R0*R0;if(I0<0)c=0;else{const P=o+d+E[a+z+E[r+w+E[C0+l]]];I0*=I0,c=I0*I0*(L[P]*O0+D[P]*S0+I[P]*Q0+_[P]*R0)}let _0=0.6-W0*W0-q0*q0-X0*X0-Z0*Z0;if(_0<0)G=0;else{const P=o+1+E[a+1+E[r+1+E[C0+1]]];_0*=_0,G=_0*_0*(L[P]*W0+D[P]*q0+I[P]*X0+_[P]*Z0)}return 27*(W+b+U+c+G)}}function A0(C){const L=new Uint8Array(512);for(let D=0;D<256;D++)L[D]=D;for(let D=0;D<255;D++){const I=D+~~(C()*(256-D)),_=L[D];L[D]=L[I],L[I]=_}for(let D=256;D<512;D++)L[D]=L[D-256];return L}var b0=Math.sqrt(3),U0=Math.sqrt(5),y0=0.5*(b0-1),B0=(3-b0)/6;var x0=(U0-1)/4,R=(5-U0)/20,v=(C)=>Math.floor(C)|0,h0=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]),Y0=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),H0=new Float64Array([0,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,1,0,1,1,1,0,1,-1,1,0,-1,1,1,0,-1,-1,-1,0,1,1,-1,0,1,-1,-1,0,-1,1,-1,0,-1,-1,1,1,0,1,1,1,0,-1,1,-1,0,1,1,-1,0,-1,-1,1,0,1,-1,1,0,-1,-1,-1,0,1,-1,-1,0,-1,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,0]);var k0=l0(j0(),1),G0=function(C,E,L){return(E-C)*L+C};class t{noise2D;noise3D;noise4D;seed;_min=-1;_max=1;_scale=1;_power=1;shift={x:0,y:0};octaves=0;_gain=0.5;_lacunarity=2;amps=[];_sharpness=0;_steps=0;_warp=0;_warpNoise;_warp2=0;_warpNoise2;tileX=!1;tileY=!1;position={x:0,y:0};pngr;layers=[];constructor(C={}){this.seed=C.seed??Math.random(),this.pngr=k0.default(this.seed),this.min=C.min??-1,this.max=C.max??1,this.scale=C.scale??1,this.power=C.power??1,this.octaves=C.octaves??C.layers?.length??0,this.gain=C.gain??0.5,this.lacunarity=C.lacunarity??2,this.sharpness=C.sharpness??0,this.steps=C.steps??0,this.warp=C.warp??0,this.warpNoise=C.warpNoise,this.warp2=C.warp2??0,this.warpNoise2=C.warpNoise2,this.amps=C.amps??[],this.tileX=C.tileX??C.tile??!1,this.tileY=C.tileY??C.tile??!1,this.createLayers(C)}createLayers(C){for(let E=0;E<this.octaves;E++){const L=C.layers?.[E]??{};if(L instanceof t){this.layers[E]=L;continue}if(L.seed===void 0)L.seed=this.pngr();this.layers[E]=new t(L)}if(this.layers.length==0)this.noise2D=c0(this.pngr),this.noise3D=N0(this.pngr),this.noise4D=u0(this.pngr)}warpPosition(C,E){if(C==null||C==0)return;if(E!=null)E.position=this.position;let L=this.position.x,D=this.position.y,I=this.position.z,_=this.position.w;const B=E??this,H=this.scale;if(this.position.x=L+54.47*H,this.position.y=D-34.98*H,I!=null)this.position.z=I+21.63*H;if(_!=null)this.position.w=_-67.1*H;if(L+=B.getFBM()*C,D+=B.getFBM()*C,I!=null)I+=B.getFBM()*C;if(_!=null)_+=B.getFBM()*C;this.position.x=L,this.position.y=D,this.position.z=I,this.position.w=_}tilePosition(){if(!this.tileX&&!this.tileY)return;const C=this.position.x,E=this.position.y;let L=0,D=0,I=0,_=0;if(this.tileX)L=Math.sin(C*Math.PI*2),D=Math.cos(C*Math.PI*2);if(this.tileY)I=Math.sin(E*Math.PI*2),_=Math.cos(E*Math.PI*2);if(this.tileX&&!this.tileY)this.position.x=L,this.position.y=D+E;else if(this.tileY&&!this.tileX)this.position.x=I+C,this.position.y=_;else if(this.tileX&&this.tileY)this.position.x=L,this.position.y=D,this.position.z=I,this.position.w=_}getFBM(){const C=this.position.x,E=this.position.y,L=this.position.z,D=this.position.w,I=this.scale;if(this.layers.length==0){if(L!=null&&D!=null&&this.noise4D!=null)return this.noise4D(C*I,E*I,L*I,D*I);if(L!=null&&this.noise3D!=null)return this.noise3D(C*I,E*I,L*I);if(this.noise2D!=null)return this.noise2D(C*I,E*I);return 0}let _=1,B=1,H=I;const S=this.lacunarity,K=this.gain;let T=0;for(let W=0;W<this.octaves;W++){const b=this.layers[W],U=this.amps[W]??1,c=b.get(C*H,E*H,L!=null?L*H:void 0,D!=null?D*H:void 0)*B*U;T+=c,B*=K,H*=S,_+=B*U}return T/_}applyShift(){const C=this.shift;if(C!==void 0){if(this.position.x+=C.x,this.position.y+=C.y,this.position.z)this.position.z+=C.z??0;if(this.position.w)this.position.w+=C.w??0}}applyPower(C){const E=this.power;if(E!=1)C=(Math.pow((C+1)*0.5,E)-0.5)*2;return C}applySharpness(C){const E=this.sharpness;if(E!=0){const L=(Math.abs(C)-0.5)*2,D=(0.5-Math.abs(C))*2;C=G0(C,L,Math.max(0,E)),C=G0(C,D,Math.max(0,-E))}return C}applySteps(C){const E=this.steps;if(E!=0)C=(C+1)*0.5,C=Math.floor(C*E)/E,C=C*2-1;return C}getNoise(C,E,L=void 0,D=void 0){this.position.x=C,this.position.y=E,this.position.z=L,this.position.w=D,this.applyShift(),this.tilePosition(),this.warpPosition(this.warp,this.warpNoise),this.warpPosition(this.warp2,this.warpNoise2);let I=this.getFBM();return I=this.applyPower(I),I=this.applySharpness(I),I=this.applySteps(I),I}get(C,E=void 0,L=void 0,D=void 0){const I=this.normalized(C,E,L,D);return this.normalizedToMinMax(I)}normalized(C,E=void 0,L=void 0,D=void 0){if(Array.isArray(C))D=C[3],L=C[2],E=C[1],C=C[0];else if(typeof C==="object")D=C.w,L=C.z,E=C.y,C=C.x;return E=E??0,this.getNoise(C,E,L,D)}minMaxToNormalized(C){return(C-this.min)/(this.max-this.min)*2-1}normalizedToMinMax(C){return(C+1)*0.5*(this.max-this.min)+this.min}move(C,E,L=void 0,D=void 0){if(!this.shift){this.shift={x:C,y:E,z:L,w:D};return}if(this.shift.x+=C,this.shift.y+=E,L!=null)this.shift.z=(this.shift.z??0)+L;if(D!=null)this.shift.w=(this.shift.w??0)+D;return this}checkParameterInput(C){if(typeof C==="object"&&!(C instanceof t)){if(C.seed===void 0)C.seed=this.pngr();C=new t(C)}return C}getParameter(C){if(typeof C==="number")return C;return C.get(this.position)}get min(){return this.getParameter(this._min)}set min(C){this._min=this.checkParameterInput(C)}get max(){return this.getParameter(this._max)}set max(C){this._max=this.checkParameterInput(C)}get scale(){return this.getParameter(this._scale)}set scale(C){this._scale=this.checkParameterInput(C)}get power(){return this.getParameter(this._power)}set power(C){this._power=this.checkParameterInput(C)}get gain(){return this.getParameter(this._gain)}set gain(C){this._gain=this.checkParameterInput(C)}get lacunarity(){return this.getParameter(this._lacunarity)}set lacunarity(C){this._lacunarity=this.checkParameterInput(C)}get sharpness(){return this.getParameter(this._sharpness)}set sharpness(C){this._sharpness=this.checkParameterInput(C)}get steps(){return Math.round(this.getParameter(this._steps))}set steps(C){this._steps=this.checkParameterInput(C)}get warp(){return this.getParameter(this._warp)}set warp(C){this._warp=this.checkParameterInput(C)}get warpNoise(){return this._warpNoise}set warpNoise(C){if(C==null){this._warpNoise=void 0;return}const E=this.checkParameterInput(C);if(E instanceof t)this._warpNoise=E}get warp2(){return this.getParameter(this._warp2)}set warp2(C){this._warp2=this.checkParameterInput(C)}get warpNoise2(){return this._warpNoise2}set warpNoise2(C){if(C==null){this._warpNoise2=void 0;return}const E=this.checkParameterInput(C);if(E instanceof t)this._warpNoise2=E}}export{t as default,t as UberNoise};
